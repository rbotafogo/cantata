---
title: "Galaaz Manual"
subtitle: "How to tightly couple Ruby and R in GraalVM"
author: "Rodrigo Botafogo"
tags: [Galaaz, Ruby, R, TruffleRuby, FastR, GraalVM, ggplot2]
date: "2019"
output:
  html_document:
    self_contained: true
    keep_md: true
  md_document:
    variant: markdown_github
  pdf_document:
    includes:
      in_header: "../../sty/galaaz.sty"
    keep_tex: yes
    number_sections: yes
    toc: true
    toc_depth: 2
fontsize: 11pt
---

```{ruby setup, echo=FALSE}
R.install_and_loads('kableExtra')
```

# Introduction

Galaaz is a system for tightly coupling Ruby and R. Ruby is a powerful language, with a large 
community, a very large set of libraries and great for web development. However, it lacks 
libraries for data science, statistics, scientific plotting and machine learning. On the 
other hand, R is considered one of the most powerful languages for solving all of the above 
problems. Maybe the strongest competitor to R is Python with libraries such as NumPy, 
Panda, SciPy, SciKit-Learn and a couple more.

# System Compatibility

* Oracle Linux 7
* Ubuntu 18.04 LTS
* Ubuntu 16.04 LTS
* Fedora 28
* macOS 10.14 (Mojave)
* macOS 10.13 (High Sierra)

# Dependencies

* TruffleRuby
* FastR


# Installation

* Install GrallVM (http://www.graalvm.org/)
* Install Ruby (gu install Ruby)
* Install FastR (gu install R)
* Install rake if you want to run the specs and examples (gem install rake)

# Usage

* Interactive shell: use 'gstudio' on the command line

  > gstudio

```{ruby simple_example}
  vec = R.c(1, 2, 3, 4)
  puts vec
```
  
* Run all specs

  > galaaz specs:all
  
* Run graphics slideshow (80+ graphics)

  > galaaz sthda:all
  
* Run labs from Introduction to Statistical Learning with R

  > galaaz islr:all

* See all available examples

  > galaaz -T
  
  Shows a list with all available executalbe tasks.  To execute a task, substitute the
  'rake' word in the list with 'galaaz'.  For instance, the following line shows up
  after 'galaaz -T'
  
  rake master_list:scatter_plot        # scatter_plot from:....
  
  execute
  
  > galaaz master_list:scatter_plot

# gKnitting a Document

This manual has been formatted usign gKnit.  gKnit uses Knitr and R markdown to knit 
a document in Ruby or R and output it in any of the available formats for R markdown.  
gKnit runs atop of GraalVM, and Galaaz.  In gKnit, Ruby variables are persisted between 
chunks, making it an ideal solution for literate programming.  
Also, since it is based on Galaaz, Ruby chunks can have access to R variables and Polyglot 
Programming with Ruby and R is quite natural.

gknit was describe in more depth in:

* xxx.xxxx.xxx

# Vector

Vectors can be thought of as contiguous cells containing data. Cells are accessed through
indexing operations such as x[5]. Galaaz has six basic (‘atomic’) vector types: logical, 
integer, real, complex, string (or character) and raw. The modes and storage modes for the 
different vector types are listed in the following
table.

| typeof    | mode      | storage.mode |
|-----------|:---------:|-------------:|
| logical   | logical   |      logical |
| integer   | numeric   |      integer |
| double    | numeric   |       double |
| complex   | complex   |      comples |
| character | character |    character |
| raw       | raw       |          raw |

Single numbers, such as 4.2, and strings, such as "four point two" are still vectors, of length
1; there are no more basic types. Vectors with length zero are possible (and useful).
String vectors have mode and storage mode "character". A single element of a character
vector is often referred to as a character string.

To create a vector the 'c' (concatenate) method from the 'R' module should be used:

```{ruby integer}
@vec = R.c(1, 2, 3)
puts @vec
```

Lets take a look at the type, mode and storage.mode of our vector @vec.  In order to print
this out, we are creating a data frame 'df' and printing it out.  A data frame, for those
not familiar with it, is basically a table.  Here we create the data frame and add the 
column name by passing named parameters for each column, such as 'typeof:', 'mode:' and
'storage__mode?'.  You should also note here that the double underscore is converted to a '.'.
So, when printed 'storage\_\_mode' will actually print as 'storage.mode'.

Data frames will later be more carefully described.  In R, the method used to create a 
data frame is 'data.frame', in Galaaz we use 'data\_\_frame'.

```{ruby typeof_integer}
df = R.data__frame(typeof: @vec.typeof, mode: @vec.mode, storage__mode: @vec.storage__mode)
puts df
```

If you want to create a vector with floating point numbers, then we need at least one of the
vector's element to be a float, such as 1.0.  R users should be careful, since in R a number
like '1' is converted to float and to have an integer the R developer will use '1L'. Galaaz
follows normal Ruby rules and the number 1 is an integer and 1.0 is a float.

```{ruby float}
@vec = R.c(1.0, 2, 3)
puts @vec
```

```{ruby typeof_float}
df = R.data__frame(typeof: @vec.typeof, mode: @vec.mode, storage__mode: @vec.storage__mode)
outputs df.kable.kable_styling
```

In this next example we try to create a vector with a variable 'hello' that has not yet
being defined.  This will raise an exception that is printed out.  We get two return blocks,
the first with a message explaining what went wrong and the second with the full backtrace
of the error.

```{ruby r_exception}
vec = R.c(1, hello, 5)
```

Here is a vector with logical values

```{ruby logical_vector}
@vec = R.c(true, true, false, false, true)
puts @vec
```

## Combining Vectors

The 'c' functions used to create vectors can also be used to combine two vectors:

```{ruby combining_vectors}
@vec1 = R.c(10.0, 20.0, 30.0)
@vec2 = R.c(4.0, 5.0, 6.0)
@vec = R.c(@vec1, @vec2)
puts @vec
```
In galaaz, methods can be chainned (somewhat like the pipe operator in R %>%, but more generic).
In this next example, method 'c' is chainned after '@vec1'.  This also looks like 'c' is a 
method of the vector, but in reallity, this is actually closer to the pipe operator.  When
Galaaz identifies that 'c' is not a method of 'vec' it actually tries to call 'R.c' with 
'@vec1' as the first argument concatenated with all the other available arguments.  The code
bellow is automatically converted to the code above.

```{ruby chainning_methods}
@vec = @vec1.c(@vec2)
puts @vec
```

## Vector Arithmetic

Arithmetic operations on vectors are performed element by element:

```{ruby vec_arith1}
puts @vec1 + @vec2
```

```{ruby mult}
puts @vec1 * 5
```

When vectors have different length, a recycling rule is applied to the shorter vector:

```{ruby recycle}
@vec3 = R.c(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0)
puts @vec4 = @vec1 + @vec3
```

## Vector Indexing

Vectors can be indexed by using the '[]' operator:

```{ruby index}
puts @vec4[3]
```

We can also index a vector with another vector.  For example, in the code bellow, we take elements
1, 3, 5, and 7 from @vec3:

```{ruby index_by_vector}
puts @vec4[R.c(1, 3, 5, 7)]
```

Repeating an index and having indices out of order is valid code:

```{ruby repeated_index}
puts @vec4[R.c(1, 3, 3, 1)]
```

It is also possible to index a vector with a negative number or negative vector.  In these cases
the indexed values are not returned:

```{ruby neg_index}
puts @vec4[-3]
puts @vec4[-R.c(1, 3, 5, 7)]
```

If an index is out of range, a missing value (NA) will be reported.

```{ruby out_of_range}
puts @vec4[30]
```

It is also possible to index a vector by range:

```{ruby range}
puts @vec4[(2..5)]
```

Elements in a vector can be named using the 'names' attribute of a vector: 

```{ruby naming}
full_name = R.c("Rodrigo", "A", "Botafogo")
full_name.names = R.c("First", "Middle", "Last")
puts full_name
```

Or it can also be named by using the 'c' function with named paramenters:

```{ruby named_param}
full_name = R.c(First: "Rodrigo", Middle: "A", Last: "Botafogo")
puts full_name
```

## Extracting Native Ruby Types from a Vector

Vectors created with 'R.c' are of class R::Vector.  You might have noticed that when indexing a
vector, a new vector is returned, even if this vector has one single element. In order to use
R::Vector with other ruby classes it might be necessary to extract the actual Ruby native type
from the vector. In order to do this extraction the '>>' operator is used.

```{ruby ruby_native}
puts @vec4
puts @vec4 >> 0
puts @vec4 >> 4
```

Note that indexing with '>>' starts at 0 and not at 1, also, we cannot do negative indexing.

# Accessing R variables

Galaaz allows Ruby to access variables created in R.  For example, the 'mtcars' data set is 
available in R and can be accessed from Ruby by using the 'tilda' operator followed by the
symbol for the variable, in this case ':mtcar'.  In the code bellow method 'outputs' is 
used to output the 'mtcars' data set nicely formatted in HTML by use of the 'kable' and
'kable_styling' functions. Method 'outputs' is only available when used with 'gknit'.

```{ruby view_kable}
outputs (~:mtcars).kable.kable_styling
```

# Matrix

A matrix is a collection of elements organized as a two dimensional table.  A matrix can be 
created by the 'matrix' function:

```{ruby matrix}
@mat = R.matrix(R.c(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0),
                nrow: 3,
                ncol: 3)

puts @mat
```
Note that matrices data is organized by column first. It is possible to organize the matrix
memory by row first passing an extra argument to the 'matrix' function:

```{ruby matrix_rowfirst}
@mat_row = R.matrix(R.c(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0),
                nrow: 3,
                ncol: 3,
                byrow: true)

puts @mat_row
```

## Indexing a Matrix

A matrix can be indexed by [row, column]:

```{ruby matrix_index}
puts @mat_row[1, 1]
puts @mat_row[2, 3]
```
It is possible to index an entire row or column with the ':all' keyword

```{ruby matrix_index_all}
puts @mat_row[1, :all]
puts @mat_row[:all, 2]
```

Indexing with a vector is also possible for matrices. In the following example we want
rows 1 and 3 and columns 2 and 3 building a 2 x 2 matrix.

```{ruby matrix_index_vector}
puts @mat_row[R.c(1, 3), R.c(2, 3)]
```

Matrices can be combined with functions 'rbind' and 'cbind'

```{ruby matrix_combine}
puts @mat_row.rbind(@mat)
puts @mat_row.cbind(@mat)
```

# List

A list is a data structure that can contain sublists of different types, while vector and matrix
can only hold one type of element.

```{ruby list}
nums = R.c(1.0, 2.0, 3.0)
strs = R.c("a", "b", "c", "d")
bool = R.c(true, true, false)
@lst = R.list(nums: nums, strs: strs, bool: bool)
puts @lst
```

Note that '@lst' elements are named elements.


## List Indexing

List indexing, also called slicing, is done using the '[]' operator and the '[[]]' operator. Let's
first start with the '[]' operator. The list above has three sublist indexing with '[]' will 
return one of the sublists.

```{ruby list_indexing}
puts @lst[1]
```

Note that when using '[]' a new list is returned.  When using the double square bracket operator
the value returned is the actual element of the list in the given position and not a slice of
the original list


```{ruby list_indexing_single}
puts @lst[[1]]
```

When elements are named, as dones with @lst, indexing can be done by name:

```{ruby list_indexing_by_name}
puts @lst[['bool']][[1]] >> 0
```

In this example, first the 'bool' element of the list was extracted, not as a list, but as a vector,
then the first element of the vector was extracted (note that vectors also accept the '[[]]' 
operator) and then the vector was indexed by its first element, extracting the native Ruby type.


# Data Frame


[TO BE CONTINUED...]


# Contributing


* Fork it
* Create your feature branch (git checkout -b my-new-feature)
* Write Tests!
* Commit your changes (git commit -am 'Add some feature')
* Push to the branch (git push origin my-new-feature)
* Create new Pull Request

