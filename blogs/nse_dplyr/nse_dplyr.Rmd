---
title: "Non Standard Evaluation in dplyr with Galaaz"
author:
    - "Rodrigo Botafogo"
    - "Daniel Mossé - University of Pittsburgh"
tags: [Tech, Data Science, Ruby, R, GraalVM]
date: "20/02/2019"
output:
  html_document:
    self_contained: true
    keep_md: true
  pdf_document:
    includes:
      in_header: ["../../sty/galaaz.sty"]
    number_sections: yes
---

```{r setup, echo=FALSE, message = FALSE}
library('dplyr')
library('tibble')
```

# Introduction

In this post we will see how to program with dplyr in Galaaz.  

### But first, what is Galaaz??

Galaaz is a system for tightly coupling Ruby and R.  Ruby is a powerful language, with
a large community, a very large set of libraries and great for web development.  However,
it lacks libraries for data science, statistics, scientific plotting and machine learning.
On the other hand, R is considered one of the most powerful languages for solving all of the
above problems.  Maybe the strongest competitor to R is Python with libraries such as NumPy,
Panda, SciPy, SciKit-Learn and a couple more.

With Galaaz we do not intend to re-implement any of the scientific libraries in R. However, we 
allow for very tight coupling between the two languages to the point that the Ruby 
developer does not need to know that there is an R engine running.  For this to happen we 
use new technologies provided by Oracle: GraalVM, TruffleRuby and FastR:

     GraalVM is a universal virtual machine for running applications
     written in JavaScript, Python 3, Ruby, R, JVM-based languages like Java,
     Scala, Kotlin, and LLVM-based languages such as C and C++.

     GraalVM removes the isolation between programming languages and enables
     interoperability in a shared runtime. It can run either standalone or in
     the context of OpenJDK, Node.js, Oracle Database, or MySQL.

     GraalVM allows you to write polyglot applications with a seamless way to
     pass values from one language to another. With GraalVM there is no copying
     or marshaling necessary as it is with other polyglot systems. This lets
     you achieve high performance when language boundaries are crossed. Most
     of the time there is no additional cost for crossing a language boundary
     at all.

     Often developers have to make uncomfortable compromises that require them
     to rewrite their software in other languages. For example:

      * “That library is not available in my language. I need to rewrite it.” 
      * “That language would be the perfect fit for my problem, but we cannot
        run it in our environment.” 
      * “That problem is already solved in my language, but the language is
        too slow.”
    
    With GraalVM we aim to allow developers to freely choose the right language
    for the task at hand without making compromises.

Interested readers should also check out the following sites:

* [GraalVM Home](https://www.graalvm.org/)
* [TruffleRuby](https://github.com/oracle/truffleruby)
* [FastR](https://github.com/oracle/fastr)
* [Faster R with FastR](https://medium.com/graalvm/faster-r-with-fastr-4b8db0e0dceb)

### Programming with dplyr

According to Hardley (https://dplyr.tidyverse.org/articles/programming.html)

> Most dplyr functions use non-standard evaluation (NSE). This is a catch-all term that 
> means they don’t follow the usual R rules of evaluation. Instead, they capture the 
> expression that you typed and evaluate it in a custom way. This has two main 
> benefits for dplyr code:

> Operations on data frames can be expressed succinctly because you don’t need to repeat 
> the name of the data frame. For example, you can write filter(df, x == 1, y == 2, z == 3) 
> instead of df[df$x == 1 & df$y ==2 & df$z == 3, ].

> dplyr can choose to compute results in a different way to base R. This is important for 
> database backends because dplyr itself doesn’t do any work, but instead generates the SQL 
> that tells the database what to do.

> Unfortunately these benefits do not come for free. There are two main drawbacks:

> Most dplyr arguments are not referentially transparent. That means you can’t replace a value 
> with a seemingly equivalent object that you’ve defined elsewhere. In other words, this code:

```{r tibble, eval=FALSE}
df <- data.frame(x = 1:3, y = 3:1)
print(filter(df, x == 1))
#> # A tibble: 1 x 2
#>       x     y
#>   <int> <int>
#> 1     1     3
```
> Is not equivalent to this code:

```{r my_var_err, eval = FALSE}
my_var <- x
#> Error in eval(expr, envir, enclos): object 'x' not found
filter(df, my_var == 1)
#> Error: object 'my_var' not found
```
> This makes it hard to create functions with arguments that change how dplyr verbs are computed.

In this post we will see that programming with dplyr in Galaaz does not require knowledge of
non-standard evaluation in R and can be accomplished by utilizing normal Ruby constructs.

# Writing Expressions in Galaaz

Galaaz extends Ruby to work with complex expressions, similar to R's expressions build with 'quote' 
(base R) or 'quo' (tidyverse).  Let's take a look at some of those expressions.

## Expressions from operators

The code bellow 
creates an expression summing two symbols

```{ruby expressions}
exp1 = :a + :b
puts exp1
```
We can build any complex mathematical expression

```{ruby expr2}
exp2 = (:a + :b) * 2.0 + :c ** 2 / :z
puts exp2
```

It is also possible to use inequality operators in building expressions

```{ruby expr3}
exp3 = (:a + :b) >= :z
puts exp3
```

Galaaz provides both symbolic representations for operators, such as (>, <, !=) as functional 
notation for those operators such as (.gt, .ge, etc.).  So the same expression written 
above can also be written as

```{ruby expr4}
exp4 = (:a + :b).ge :z
puts exp4
```

Two type of expression can only be created with the functional representation of the operators, 
those are expressions involving '==', and '='.  In order to write an expression involving '==' we
need to use the method '.eq' and for '=' we need the function '.assign'

```{ruby expr5}
exp5 = (:a + :b).eq :z
puts exp5
```

```{ruby expr6}
exp6 = :y.assign :a + :b
puts exp6
```
In general we think that using the functional notation is preferable to using the 
symbolic notation as otherwise, we end up writing invalid expressions such as

```{ruby exp_wrong, warning=FALSE}
exp_wrong = (:a + :b) == :z
puts exp_wrong
```
and it might be difficult to understand what is going on here.  The problem lies with the fact that
when using '==' we are comparing expression (:a + :b) to expression :z with '=='.  When the 
comparison is executed, the system tries to evaluate :a, :b and :z, and those symbols at 
this time are not bound to anything and we get a "object 'a' not found" message.
If we only use functional notation, this type of error will not occur.

## Expressions with R methods

It is often necessary to create an expression that uses a method or function.  For instance, in
mathematics, it's quite natural to write an expressin such as $y = sin(x)$. In this case, the
'sin' function is part of the expression and should not immediately executed. Now, let's say
that 'x' is an angle of 45$^\circ$ and we acttually want our expression to be $y = 0.850...$.
When we want the function to be part of the expression, we call the function preceeding it
by the letter E, such as 'E.sin(x)'

```{ruby method_expression}
exp7 = :y.assign E.sin(:x)
puts exp7
```

# Using Galaaz to call R functions

Galaaz tries to emulate as closely as possible the way R functions are called and migrating from 
R to Galaaz should be quite easy requiring only minor syntactic changes to an R script.  In 
this post, we do not have enough space to write a complety manual to Galaaz, so we will 
present only a few examples scripts using Galaaz.

Basically, to call an R function from Ruby with Galaaz, one only needs to preceed the function
with 'R.'.  For instance, to create a vector in R, the 'c' function is used.  From Galaaz, a
vector can be created by using 'R.c':

```{ruby vector}
@vec = R.c(1.0, 2, 3)
puts @vec
```
A list is created in R with the 'list' function, so in Galaaz we do:

```{ruby list}
@list = R.list(a: 1.0, b: 2, c: 3)
puts @list
```
Note that we can use named arguments in our list.  The same code in R would be:

```{r list2}
lst = list(a = 1, b = 2L, c = 3L)
print(lst)
```


However, if we want the function to be evaluated, then
we use the normal call to function with R as 'R.sin(x)'.

```{ruby method_exc}
x = 45
exp8 = :y.assign R.sin(x)
puts exp8
```


# Filtering using expressions

Now that we now how to write expression, we can use then to filter a data frame by expressions.  
Let's first start by creating a simple data frame with two columns named 'x' and 'y'

```{ruby df}
@df = R.data__frame(x: (1..3), y: (3..1))
puts @df
```
In the code bellow we want to filter the data frame by rows in which the value of 'x' is
equal to 1.

```{ruby filter_exp}
puts @df.filter(:x.eq 1)
```

In R, and when coding with 'tidyverse', arguments to a function are usually not 
*referencially transparent*. That is, ou can’t replace a value with a seemingly equivalent 
object that you’ve defined elsewhere. In other words, this code

```{r not_transp, eval=FALSE}
my_var <- x
filter(df, my_var == 1)
```
Generates the following error: "object 'x' not found.

However, in Ruby and Galaaz, arguments are referencially transparent as can be seen by the 
code bellow.  Note, initally that 'my_var = :x' will not give the error "object 'x' not found" 
since ':x' is treated as an expression and assigned to my\_var. Then when doing (my\_var.eq 1), 
my\_var is a variable that resolves to ':x' and it becomes equivalent to (:x.eq 1) which is
what we want.

```{ruby my_var}
my_var = :x
puts @df.filter(my_var.eq 1)
```
As stated by Hardley

> dplyr code is ambiguous. Depending on what variables are defined where, 
> filter(df, x == y) could be equivalent to any of:

```
df[df$x == df$y, ]
df[df$x == y, ]
df[x == df$y, ]
df[x == y, ]
```
In galaaz this ambiguity does not exist, filter(df, x.eq y) is not a valid expression as 
expressions are build with symbols.  In doing filter(df, :x.eq y) we are looking for elements
of the 'x' column that are equal to a previously defined y variable.  Finally, 
filter(df, :x.eq :y) we are looking for elements in which the 'x' column value is equal to
the 'y' column value. This can be seen in the following two chunks of code:

```{ruby disamb1}
@y = 1
@x = 2

# looking for values where the 'x' column is equal to the 'y' column
puts @df.filter(:x.eq :y)
```

```{ruby disamb2}
# looking for values where the 'x' column is equal to the 'y' variable
# in this case, the number 1
puts @df.filter(:x.eq @y)
```
# Writing a function that applies to different data sets



```
mutate(df1, y = a + x)
mutate(df2, y = a + x)
mutate(df3, y = a + x)
mutate(df4, y = a + x)
```

Here we create a mutate_y Ruby method.

```{ruby mutate_y, warning=FALSE}
def mutate_y(df)
  df.mutate(:y.assign :a + :x)
end
```

Note that contrary to what happens in R, method mutate_y will fail independetly from the fact
that variable 'a' is defined or not.

```{ruby call_mutate, warning=FALSE}
df1 = R.data__frame(x: (1..3))
puts df1
a = 10
mutate_y(df1)
```

# Different expressions

```{r diff_expr}
df <- data.frame(
  g1 = c(1, 1, 2, 2, 2),
  g2 = c(1, 2, 1, 2, 1),
  a = sample(5),
  b = sample(5)
)

d2 <- df %>%
  group_by(g1) %>%
  summarise(a = mean(a))
	       
as.data.frame(d2)	       

d2 <- df %>%
  group_by(g2) %>%
  summarise(a = mean(a))
	       
as.data.frame(d2)	       
```

Trying to write a function in R that will receive two argumens, the first a variable and
the second an expression is not trivia. As shown by Hardley, one might expect this function 
to do the trick:

```{r diff_exp_fnc}
my_summarise <- function(df, group_var) {
  df %>%
    group_by(group_var) %>%
    summarise(a = mean(a))
}

# my_summarise(df, g1)
#> Error: Column `group_var` is unknown
```

In order to solve this problem, coding with dplyr requires the introduction of many new concepts
and functions such as 'quo', 'quos', 'enquo', 'enquos', '!!' (bang bang), '!!!' (triple bang).

Now, let's try to implement the same function in galaaz.  The next code block first prints the
'df' data frame define previously in R, then creates the my_summarize function and calls it 
passing the R data frame and the group by variable ':g1'

```{ruby diff_exp_ruby_func}
puts ~:df
print "\n"

def my_summarize(df, group_var)
  df.group_by(group_var).
    summarize(a: E.mean(:a))
end

puts my_summarize((~:df), :g1).as__data__frame
```
It works!!! Well let's make sure this was not just some coincidence

```{ruby group_g2}
puts my_summarize((~:df), :g2).as__data__frame
```

Great, everything is fine! No magic, no new functions, no complexities, just normal, standard Ruby
code.  If you've ever done NSE in R, this certainly feels much safer and easy to implement.

# Different input variables

In the previous section we've managed to get rid of all NSE formulation for a simple example, but
does this remain true for more complex examples, or will the Ruby way prove inpractical for
more complex code?

In the next example Hardley proposes us to write a function that given an expression such as 'a'
or 'a * b', calculates three summaries.  What we want a function that does the same as these R
statements:

```
summarise(df, mean = mean(a), sum = sum(a), n = n())
#> # A tibble: 1 x 3
#>    mean   sum     n
#>   <dbl> <int> <int>
#> 1     3    15     5

summarise(df, mean = mean(a * b), sum = sum(a * b), n = n())
#> # A tibble: 1 x 3
#>    mean   sum     n
#>   <dbl> <int> <int>
#> 1   9.6    48     5
```

Let's try it in galaaz:

```{ruby summarize_method}
def my_summarise2(df, expr)
  df.summarize(
    mean: E.mean(expr),
    sum: E.sum(expr),
    n: E.n
  )
end

puts my_summarise2((~:df), :a)
puts my_summarise2((~:df), :a * :b)
```

Once again, there is no need to use any special theory or functions.  The only point to be 
careful about is the use of 'E' to build an expression that uses the mean, sum and n.

# Different input and output variable

Now the next challenge presented by Hardley is to vary the name of the output variables based on 
the received expression.  So, if the input expression is 'a', we want our data frame columns to
be named 'mean\_a' and 'sum\_a'.  Now, if the input expression is 'b', columns
should be named 'mean\_b' and 'sum\_b'.

```
mutate(df, mean_a = mean(a), sum_a = sum(a))
#> # A tibble: 5 x 6
#>      g1    g2     a     b mean_a sum_a
#>   <dbl> <dbl> <int> <int>  <dbl> <int>
#> 1     1     1     1     3      3    15
#> 2     1     2     4     2      3    15
#> 3     2     1     2     1      3    15
#> 4     2     2     5     4      3    15
#> # … with 1 more row

mutate(df, mean_b = mean(b), sum_b = sum(b))
#> # A tibble: 5 x 6
#>      g1    g2     a     b mean_b sum_b
#>   <dbl> <dbl> <int> <int>  <dbl> <int>
#> 1     1     1     1     3      3    15
#> 2     1     2     4     2      3    15
#> 3     2     1     2     1      3    15
#> 4     2     2     5     4      3    15
#> # … with 1 more row
```

Here is our Ruby code

```{ruby name_change}
def my_mutate(df, expr)
  mean_name = "mean_#{expr.to_s}"
  sum_name = "sum_#{expr.to_s}"

  df.mutate(mean_name => E.mean(expr),
            sum_name => E.sum(expr))
end

puts my_mutate((~:df), :a)
puts my_mutate((~:df), :b)
```
It really seems that "Non Standard Evaluation" is actually quite standard in Galaaz! But, you 
might have noticed a small change in the way the arguments to the mutate method were called.
In a previous example we used df.summarise(mean: E.mean(:a), ...) where the column name was
followed by a ':' colom.  In this example, we have df.mutate(mean_name => E.mean(expr), ...)
and variable mean\_name is not followed by ':' but by '=>'.  This is standard Ruby notation.

[explain....]

# Capturing multiple variables

```{ruby multiple_vars}
def my_summarise3(df, *group_vars)
  df.group_by(*group_vars).
    summarise(a: E.mean(:a))
end

puts my_summarise3((~:df), :g1, :g2).as__data__frame
```

# Advanced dplyr features
https://www.r-bloggers.com/programming-with-dplyr-by-using-dplyr/

```{ruby starwars}
puts (~:starwars).head.as__data__frame
```

```{r grouped_mean}
grouped_mean <- function(data, grouping_variables, value_variables) {
  data %>%
    group_by_at(grouping_variables) %>%
    mutate(count = n()) %>%
    summarise_at(c(value_variables, "count"), mean, na.rm = TRUE) %>%
    rename_at(value_variables, funs(paste0("mean_", .)))
    }

gm = starwars %>% 
   grouped_mean("eye_color", c("mass", "birth_year"))

as.data.frame(gm)   
```

```{ruby advanced_starwars}
def grouped_mean(data, grouping_variables, value_variables)
  data.
    group_by_at(grouping_variables).
    mutate(count: E.n).
    summarise_at(E.c(value_variables, "count"), ~:mean, na__rm: true).
    rename_at(value_variables, R.funs(E.paste0("mean_", value_variables)))
end

puts grouped_mean((~:starwars), "eye_color", R.c("mass", "birth_year")).as__data__frame
```
